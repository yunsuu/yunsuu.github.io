블록스코프 let, const
변수 선언이 속해있는 블록에서만 기록되어 그 밖의 블록에서는
쓰이지 못한다 

함수스코프 var
변수선언이 속해있는 함수 안에서만 기록되어 그밖 다른 함수
혹은 상위 함수에서 쓰이지 못한다.
(for문에서 var i = 0하고 돌린다음에 콘솔을 찍어보면
돌렸던 흔적?이 나오는게 이 때문이다.)

호이스팅 -> 실행전에 뭐가 선언됬는지 체크해보자!
기존 var : 변수명만 위로 끌어올리고  undefined 할당
let, const : 변수명만 위로 끌어올리고 끝

자바스크립트에서 함수를 선언하면 
지정된 단위 안에서 변수들을 사용하고
지정된 단위안에 없는 변수는 상단 범위를 탐색한다.
(상단 스코프에서 선언된 변수이름과 같은 변수이름을 사용해야할때 
주의해야한다.)

```js
(function (){
    const a = 10;
    (function(){
        console.log(a); //a가 위에 선언이 되었지만 ReferenceError가 난다.
        const a = 20;
    })();
    console.log(a); //10
  })()
```

는 에러가 난다

객체안의 선언되는 매소드, 그 안에서 쓰이는 this는
그 객체를 담고 있지만 아닌 경우는 this는 기본적으로 window 객체를 의미한다.

```js
  var obj ={
      value : 1,
      myMethod : function(){
          this.value = 2; //obj함수의 value
          (function (){
              this.value = 3; //window객체(전역변수)의 value
          })
      }

  }
```

const에 관하여...
```js
const obj = {a : 1};
const obj = 1; //에러
const obj.a = 2; // 에러 안남
```

template literal을 중복처리 가능하다
```js
`my name is ${`yunsuu`}` // "my name is yunsuu"
```
trim 메소드를 이용해서 줄바꿈 정리를 하기도 한다.

템플릿 리터럴은 태그함수라는 것을 이용한 호출도 가능하다

string.raw를 이용해서 이스케이프 문자도 그대로 데이터 상으로
볼 수 있다.

``` js
const tag = function(strs, ...args){
    return {strs: strs, args}
}
const res = tag`순서가 ${1}이렇게 ${2}`
//strs -> ["순서가", "이렇게", ""]
//args -> [1, 2]
```

### 반복문 매소드
foreach : for 문과 똑같다. for문을 좀더 편하게
map : 배열을 이용해 새로운 "배열"을 만들 때
reduce : 배열을 이용해 새로운 "값"을 만들 때

