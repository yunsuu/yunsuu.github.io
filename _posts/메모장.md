블록스코프 let, const
변수 선언이 속해있는 블록에서만 기록되어 그 밖의 블록에서는
쓰이지 못한다 

함수스코프 var
변수선언이 속해있는 함수 안에서만 기록되어 그밖 다른 함수
혹은 상위 함수에서 쓰이지 못한다.
(for문에서 var i = 0하고 돌린다음에 콘솔을 찍어보면
돌렸던 흔적?이 나오는게 이 때문이다.)

호이스팅 -> 실행전에 뭐가 선언됬는지 체크해보자!
기존 var : 변수명만 위로 끌어올리고  undefined 할당
let, const : 변수명만 위로 끌어올리고 끝

자바스크립트에서 함수를 선언하면 
지정된 단위 안에서 변수들을 사용하고
지정된 단위안에 없는 변수는 상단 범위를 탐색한다.
(상단 스코프에서 선언된 변수이름과 같은 변수이름을 사용해야할때 
주의해야한다.)

```js
(function (){
    const a = 10;
    (function(){
        console.log(a); //a가 위에 선언이 되었지만 ReferenceError가 난다.
        const a = 20;
    })();
    console.log(a); //10
  })()
```

는 에러가 난다

객체안의 선언되는 매소드, 그 안에서 쓰이는 this는
그 객체를 담고 있지만 아닌 경우는 this는 기본적으로 window 객체를 의미한다.

```js
  var obj ={
      value : 1,
      myMethod : function(){
          this.value = 2; //obj함수의 value
          (function (){
              this.value = 3; //window객체(전역변수)의 value
          })
      }

  }
```

const에 관하여...
```js
const obj = {a : 1};
const obj = 1; //에러
const obj.a = 2; // 에러 안남
```

template literal을 중복처리 가능하다
```js
`my name is ${`yunsuu`}` // "my name is yunsuu"
```
trim 메소드를 이용해서 줄바꿈 정리를 하기도 한다.

템플릿 리터럴은 태그함수라는 것을 이용한 호출도 가능하다

string.raw를 이용해서 이스케이프 문자도 그대로 데이터 상으로
볼 수 있다.

``` js
const tag = function(strs, ...args){
    return {strs: strs, args}
}
const res = tag`순서가 ${1}이렇게 ${2}`
//strs -> ["순서가", "이렇게", ""]
//args -> [1, 2]
```

### 반복문 매소드
foreach : for 문과 똑같다. for문을 좀더 편하게
map : 배열을 이용해 새로운 "배열"을 만들 때
reduce : 배열을 이용해 새로운 "값"을 만들 때

### spread operator (펼치기 연산자)

```js
arr = [1,2,3,4]
console.log(...arr) //1~4 출력

sum = function(..args){
    //args가 인자의 값들을 배열로 받아온다.
    return result //모든 인자 값을 합한걸 result라고 했을때
}

sum(1,2,3,4,5,6) //1~6의 값을 합한 값이 나온다.
```

* 배열의 각 인자를 펼친다.
* getter(받는입장) 일때는 배열로 받아들이고
*  setter(펼치는 입장) 일때는 펼치기
* iterable(반복가능)한 모든 데이터는 펼칠 수 있다 -> 왠만한건 다 펼친다.
* 얕은 복사만 수행한다.


### shorthand property 

* json 객체 key와 value의 값이 같을때 문법을 생략함

이거와
```js
var x = 10
var y = 20
var obj = {
    x : x,
    y : y
}
```

이게 같다
```js
var x = 10
var y = 20
var obj = {
    x,
    y
}
```
### concised method

* 객체 매소드를 만들때 함수의 문법을 생략 할 수 있다.
* 매소드 본연의 성능을 향상 시킬 수 있다.
* 함수의 프로토타입 객체를 사용하지 않기 때문에 기존 함수 선언보다 가볍다.
* 생성자 함수로서의 기능은 하지 못한다.

```js
const obj = {
    name : "foo",
    getName1 () {return this.name},
    getName1 : function(){ return this.name }
}

const a = new obj.getName1() //TypeError: obj.getName1 is not a constructor
const a = new obj.getName2() //error 안남
```

### 객체의 열가 순서

1. 숫자를 오름차순으로 나열한다. 
2. 문자열을 입력 순서대로 나열한다 (음수나, 앞에 0이 붙은 숫자는 문자열) 
3. symbol이 입력된 순서로 나열된다.


### this 바인딩

1. js의 기본적으로 this 바인딩이 일어날 때는 전역객체를 바인딩한다.
2. 객체 안에서 선언된 메소드의 this 바인딩은 객체로 바인딩된다. -> 객체를 가르키게 된다

주의사항

* arrow function은 this 바인딩이 일어나지 않는다.

* 그리고 객체는 스코프를 생성하지 않는다.

* 때문에 객체 안에서 선언된 arrow function이 가르키게 되는 this는 window 전역객체이다.

```js
//기본적인 바인딩은 window 바인딩
function checkThisInNormalFunc() {
    console.log(this === window) // true
}
checkThisInNormalFunc()

//객체 안에서의 바인딩은 객체 자기 자신을 가르킨다.
var obj = {
    name: "seo",
    print: function() {
        console.log(this.name)       // seo
        console.log(this === obj)    // true
    }
}
obj.print()
```

여기서 주의할점은 메소드 방식으로 호출할때 this가 객체를 가르킨다는 점

```js
var obj = {
    print: function() {
      console.log(this == obj);
    }
}
var print = obj.print
           
obj.print();      // true (메소드 방식 호출)
print();          // false (일반함수 방식 호출)
```

new 키워드로 객체를 생성할때 this는 전역객체가 아닌 생성된 객체를 가르킨다.


```js
function printName() {
    var lastName = "seo";
    this.firstName = "jeong kuk"
    console.log(this.lastName + " " + this.firstName)
}
var lastName = "kim";
printName();               // kim jeong kuk
var o = new printName();   // undefined jeong kuk
```


### 생성자 함수
* 생성자 함수는 js가 클래스 개념을 이용하기 위해 쓰여지는 개념이다.

```js
//클래스 선언하듯이 이렇게 선언하고
function Person(name, gender) {
  this.name = name;
  this.gender = gender;
  this.sayHello = function() {
    alert(this.name + ' said "hello"');
  }
}

//new를 이용해 함수 인자에 넣어줘 리턴해주면
var zero = new Person('Zero', 'm'); // Person {name: 'Zero', gender: 'm'}
var hero = new Person('Hero', 'f'); // Person {name: 'Hero', gender: 'f'}

// Person에서 선언한 메소드들이 생성자 함수로 만들어진 객체에서 모두 사용할 수 있다.
zero.sayHello(); // 'Zero said "hello"'
hero.sayHello(); // 'Hero said "hello"'
```

* 이렇게 메소드를 사용할 수 있는 이유는 prototype 객체 안에 선언된 메소드를
공유하고 있기 때문이다.

### arrow function

//객체를 괄호없이 리턴할때는 요렇게
```js
var e = x => {x:1} // x
var e = x => ({x:1}) // o
``` 

* 실행컨택스트시 생성시 this 바인딩을 하지 않음 (중요!!!!)

<!-- * 기존 함수 선언은 실행되는 순간에 this를 바인딩
    this 바인딩이란 자바스크립트는 기본적으로 전역객체의 컨택스트가 바인딩 된다
    -> 자바스크립트의 비동기 실행을 위함인 것 같다. -->

<!-- * 에로우 함수는 전역객체 window에 바인딩 하는것이 아닌 상단 블록의 this를 참초한다
 -> 함수 b같은경우 바인딩할게 없으니까 window 전역객체를 바인딩하는 모습이다. -->

* 기존 js에서는 모든 변수, 함수를 실행전 window 객체에 등록(호이스팅) 후
실행을 진행했고 이 부분이 js가 언어가 아니라고 까인 이유 중 하나이다.
하지만 es6에서는 js의 언어로도 기능을 할 수 있도록 하기위해 일정 부분을
window로 바로 등록되는 것이 아닌 블록단위로 제어할 필요가 있었다.
이러한 아이디어에서 나온 개념들이 const, let, arrow function들이다.
선언 및 실행과정에서 window 객체에 바로 등록되는 것이 아닌
많은 프로그램 언어들 처럼 블록 단위 안에서 제어가 된다이들은 호이스팅을  진행하지 않는다.
(엄밀히 따지자면 호이스팅을 진행하긴 하지만 많은 서적에서 이해를 돕기위해
호이스팅을 진행하지 않는다고 설명하는 것 같다.)

* call apply 메소드는 정상적으로 작동한다.

* arrow 함수도 콘솔로 까보면 prototype 프로퍼티가 없다 -> 생성자 함수를 사용할 수 없다. -> 클래스를 만들 수 없다
-> concised method(객체 매소드 선언 축약)과 유사하다.

```js
const obj = {
    a: function () {
        console.log(this) // obj의 this
 
        const b = function() {
            console.log(this) //window 객체의 this
        }

        const c = () => {
            console.log(this) //obj의 this
        }
    } 
}
```
  

